<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js canvas - interactive - cubes</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
    body {
        font-family: Monospace;
        background-color: #f0f0f0;
        margin: 0px;
        overflow: hidden;
    }
    </style>
</head>

<body>
    <script src="../libs/three.min.js"></script>
    <script src="../js/renderers/Projector.js"></script>
    <script src="../js/renderers/CanvasRenderer.js"></script>
    <script src="../libs/stats.min.js"></script>
    <script>
    var container;
    var camera, scene, renderer;
    var raycaster;
    var mouse;
    var voicestate = true;
    var INTERSECTED;
    var objects = [];

    init();
    animate();

    function init() {

        container = document.createElement('div');
        document.body.appendChild(container);

        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
        camera.position.set(0, 300, 500);

        scene = new THREE.Scene();

        var geometry = new THREE.BoxGeometry(100, 100, 100);
        // var AudioOn = THREE.ImageUtils.loadTexture("../assets/audioIcon.png")
        // var mat = new THREE.MeshPhongMaterial();
        // mat.map = AudioOn;

        for (var i = 0; i < 6; i++) {

            //default to RED for 'on'
            var defaultMaterial = new THREE.MeshBasicMaterial({
                color: 0xFF0000,
                opacity: 1
            })
            var object = new THREE.Mesh(geometry, defaultMaterial);
            object.position.x = -400 + (i * 200);
            object.position.y = 0;
            object.position.z = -200;

            object.scale.x = 2;
            object.scale.y = 2;
            object.scale.z = 2;

            object.rotation.x = Math.random() * 2 * Math.PI;
            object.rotation.y = Math.random() * 2 * Math.PI;
            object.rotation.z = Math.random() * 2 * Math.PI;

            scene.add(object);
            //default to TRUE for 'on'
            object.voicestate = true

            objects.push(object);

        }




        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        renderer = new THREE.CanvasRenderer();
        renderer.setClearColor(0xf0f0f0);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);


        document.addEventListener('mousedown', onDocumentMouseDown, false);
        // document.addEventListener('mouseenter', onDocumentMouseEnter, false);
        document.addEventListener('touchstart', onDocumentTouchStart, false);
        document.addEventListener('mousemove', onDocumentMouseMove, false);


        window.addEventListener('resize', onWindowResize, false);

    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);

    }

    function onDocumentTouchStart(event) {
        console.log("touch")
        event.preventDefault();

        event.clientX = event.touches[0].clientX;
        event.clientY = event.touches[0].clientY;
        onDocumentMouseDown(event);


    }

    function onDocumentMouseMove(event) {
        event.preventDefault();

        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        // console.log(mouse.x+','+mouse.y)


    }

    function onDocumentMouseDown(event) {
        console.log('down')

        event.preventDefault();

        mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
        mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        var intersects = raycaster.intersectObjects(objects);

        if (intersects.length > 0) {

            if (intersects[0].object.voicestate == true) {
                intersects[0].object.material.color.setHex(0x808080);
                intersects[0].object.material.opacity = .5

                intersects[0].object.voicestate = false

            } else {
                intersects[0].object.material.color.setHex(0xFF0000);
                intersects[0].object.material.opacity = 1

                intersects[0].object.voicestate = true

            }
        }


    }


    function animate() {





        requestAnimationFrame(animate);
        render();
    }


    function render() {
        raycaster.setFromCamera(mouse, camera);
        var intersects = raycaster.intersectObjects(scene.children);
        // returns an array of all objects
        //if you are currently intersecting
        if (intersects.length > 0) {
            // console.log('currently intersected with something')
            console.log('intersected =' + INTERSECTED)
            if (INTERSECTED != intersects[0].object) {
                //the first object
                console.log('intersect object 0' + intersects[0].object)
                var oac = intersects[0].object.material.opacity = .8
                if (INTERSECTED) {
                    console.log("new object")
                        // intersects[0].object.material.opacity = 1

                }

                INTERSECTED = intersects[0].object;
                // INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
                // INTERSECTED.material.emissive.setHex(0xeeb000);

            }

        } else {
            console.log('no intersections')
            if (INTERSECTED) {
                console.log(intersects[0] + "stat2")
                oac = 1
                    // intersects[0].object.material.opacity = 1
                    // INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);

                // console.log('end of intersecting')
            }

            INTERSECTED = null;
            //set intersected to false

        }




        renderer.render(scene, camera);

    }
    </script>
</body>

</html>
