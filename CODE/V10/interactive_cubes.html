<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js canvas - interactive - cubes</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
    body {
        font-family: Monospace;
        background-color: #f0f0f0;
        margin: 0px;
        overflow: hidden;
    }
    </style>
</head>

<body>
    <script src="../libs/three.min.js"></script>
    <script src="../js/renderers/Projector.js"></script>
    <script src="../js/renderers/CanvasRenderer.js"></script>
    <script src="../libs/stats.min.js"></script>
    <script>
    var container;
    var camera, scene, renderer;
    var OnOffraycaster;
    var mouse;
    var voicestate = true;
    var onOffCubes = []
    var INTERSECTED;
    var objects = [];

    init();
    animate();

    function init() {

        container = document.createElement('div');
        document.body.appendChild(container);

        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
        camera.position.set(0, 300, 500);

        scene = new THREE.Scene();

        var onoffcube = new THREE.BoxGeometry(200, 100, 100);

        // var AudioOn = THREE.ImageUtils.loadTexture("../assets/audioIcon.png")
        // var mat = new THREE.MeshPhongMaterial();
        // mat.map = AudioOn;

        for (var i = 0; i < 6; i++) {

            //default to RED for 'on'
            var onoffmaterial = 

            // new THREE.MeshPhongMaterial( { color: 0xFF0000, specular: 0x990000, shininess: 30 } )



            new THREE.MeshBasicMaterial({
                color: 0xFF0000,
                opacity: 1
            })
            var onoffbutton = new THREE.Mesh(onoffcube, onoffmaterial);
            onoffbutton.position.x = -400 + (i * 200);
            onoffbutton.position.y = 0;
            onoffbutton.position.z = -200;

            onoffbutton.scale.set(1,1,1);
          

            // onoffbutton.rotation.x = Math.random() * 2 * Math.PI;
            // onoffbutton.rotation.y = Math.random() * 2 * Math.PI;
            // onoffbutton.rotation.z = Math.random() * 2 * Math.PI;

            scene.add(onoffbutton);
            //default to TRUE for 'on'
            onoffbutton.voicestate = true

            onOffCubes.push(onoffbutton);

        }




        OnOffraycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        renderer = new THREE.CanvasRenderer();
        renderer.setClearColor(0xf0f0f0);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);


        document.addEventListener('mousedown', onDocumentMouseDown, false);
        document.addEventListener('mousemove', onDocumentMouseMove, false);
        // document.addEventListener('touchstart', onDocumentTouchStart, false);


        // window.addEventListener('resize', onWindowResize, false);

    }

    // function onWindowResize() {

    //     camera.aspect = window.innerWidth / window.innerHeight;
    //     camera.updateProjectionMatrix();

    //     renderer.setSize(window.innerWidth, window.innerHeight);

    // }

    // function onDocumentTouchStart(event) {
    //     console.log("touch")
    //     event.preventDefault();

    //     event.clientX = event.touches[0].clientX;
    //     event.clientY = event.touches[0].clientY;
    //     onDocumentMouseDown(event);


    // }

    function onDocumentMouseMove(event) {
        event.preventDefault();
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    }

    function onDocumentMouseDown(event) {
        // console.log('down')

        event.preventDefault();

        mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
        mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;

        OnOffraycaster.setFromCamera(mouse, camera);

        var intersects = OnOffraycaster.intersectObjects(onOffCubes);

        if (intersects.length > 0) {

            if (intersects[0].object.voicestate == true) {
                intersects[0].object.material.color.setHex(0x808080);
                intersects[0].object.material.opacity = .5
                intersects[0].object.voicestate = false

            } else {
                intersects[0].object.material.color.setHex(0xFF0000);
                intersects[0].object.material.opacity = 1
                intersects[0].object.voicestate = true

            }
        }


    }


    function animate() {

        requestAnimationFrame(animate);
        render();
    }


    function render() {
        OnOffraycaster.setFromCamera(mouse, camera);
        var intersects = OnOffraycaster.intersectObjects(onOffCubes);
        // returns an array of all objects
        //if you are currently intersecting
        if (intersects.length > 0) {
        //     // console.log('currently intersected with something')
        //     // console.log('intersected =' + INTERSECTED)
            if (INTERSECTED != intersects[0].object) {
        //         //the first object
        //         // console.log('intersect object 0' + intersects[0].object)
        //         var oac = intersects[0].object.material.opacity = .8
                if (INTERSECTED) {
        //             // console.log("new object")
        //             // intersects[0].object.material.opacity = 1

                }

        //         INTERSECTED = intersects[0].object;
        //         INTERSECTED.currentHex = INTERSECTED.material.getHex();
        //         // INTERSECTED.material.emissive.setHex(0xeeb000);

            }

        } else {
        //     // console.log('no intersections')
            if (INTERSECTED) {
        //         // console.log(intersects[0] + "stat2")
        //         oac = 1
        //             // intersects[0].object.material.opacity = 1
        //         INTERSECTED.material = new THREE.MeshBasicMaterial({
        //             color: 0xFF0000,
        //             opacity: 1
        //         })

        //         // console.log('end of intersecting')
            }

            INTERSECTED = null;
        //     //set intersected to false

        }




        renderer.render(scene, camera);

    }
    </script>
</body>

</html>
