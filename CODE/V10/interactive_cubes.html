<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js canvas - interactive - cubes</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
    body {
        font-family: Monospace;
        background-color: #f0f0f0;
        margin: 0px;
        overflow: hidden;
    }
    </style>
</head>

<body>
    <script src="../libs/three.min.js"></script>
    <script src="../js/renderers/Projector.js"></script>
    <script src="../js/renderers/CanvasRenderer.js"></script>
    <script src="../libs/stats.min.js"></script>
    <script>
    var container, stats;
    var camera, scene, renderer;
    var particleMaterial;

    var raycaster;
    var mouse;
    var voicestate = true;

    var objects = [];

    init();
    animate();

    function init() {

        container = document.createElement('div');
        document.body.appendChild(container);

        var info = document.createElement('div');
        info.style.position = 'absolute';
        info.style.top = '10px';
        info.style.width = '100%';
        info.style.textAlign = 'center';
        info.innerHTML = '<a href="http://threejs.org" target="_blank">three.js</a> - clickable objects';
        container.appendChild(info);

        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
        camera.position.set(0, 300, 500);

        scene = new THREE.Scene();

        var geometry = new THREE.BoxGeometry(100, 100, 100);
        var AudioOn = THREE.ImageUtils.loadTexture("../assets/audioIcon.png")
         var mat = new THREE.MeshPhongMaterial(); 
         mat.map = AudioOn;

        for (var i = 0; i < 6; i++) {
            // var texture = new THREE.Texture(generateTexture()); // texture background is transparent
            // texture.needsUpdate = true; // important
            // // uniforms
            // var uniforms = {
            //     color: {
            //         type: "c",
            //         value: new THREE.Color(0xff0000)
            //     }, // material is "red"
            //     texture: {
            //         type: "t",
            //         value: texture
            //     },
            // };
            // var materialShader = new THREE.ShaderMaterial({
            //     uniforms: uniforms,
            //     vertexShader: document.getElementById('vertex_shader').textContent,
            //     fragmentShader: document.getElementById('fragment_shader').textContent
            // });

var defaultMaterial = new THREE.MeshBasicMaterial({
                color: 0xFF0000,
                opacity: 1
            })
            var object = new THREE.Mesh(geometry, mat);
            object.position.x = Math.random() * 800 - 400;
            object.position.y = Math.random() * 800 - 400;
            object.position.z = Math.random() * 800 - 400;

            object.scale.x = Math.random() * 2 + 1;
            object.scale.y = Math.random() * 2 + 1;
            object.scale.z = Math.random() * 2 + 1;

            object.rotation.x = Math.random() * 2 * Math.PI;
            object.rotation.y = Math.random() * 2 * Math.PI;
            object.rotation.z = Math.random() * 2 * Math.PI;

            scene.add(object);
            object.voicestate = true
                // console.log(object.voicestate)

            objects.push(object);

        }

        // var PI2 = Math.PI * 2;


        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        renderer = new THREE.CanvasRenderer();
        renderer.setClearColor(0xf0f0f0);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);

        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        container.appendChild(stats.domElement);

        document.addEventListener('mousedown', onDocumentMouseDown, false);
        document.addEventListener('mouseover', onDocumentMouseOver, false);
        document.addEventListener('touchstart', onDocumentTouchStart, false);

        //

        window.addEventListener('resize', onWindowResize, false);

    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);

    }

    function onDocumentTouchStart(event) {


        event.preventDefault();

        event.clientX = event.touches[0].clientX;
        event.clientY = event.touches[0].clientY;
        onDocumentMouseDown(event);

    }

    function onDocumentMouseDown(event) {

        event.preventDefault();

        mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
        mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        var intersects = raycaster.intersectObjects(objects);

        if (intersects.length > 0) {

            if (intersects[0].object.voicestate == true) {
                intersects[0].object.material.color.setHex(0x808080);
                intersects[0].object.material.opacity = .5

                intersects[0].object.voicestate = false

            } else {
                intersects[0].object.material.color.setHex(0xFF0000);
                intersects[0].object.material.opacity = 1

                intersects[0].object.voicestate = true

            }
        }


    }

    function onDocumentMouseOver(event) {
        console.log('mouseover')
        event.preventDefault();

        mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
        mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        var intersects = raycaster.intersectObjects(objects);

        if (intersects.length > 0) {

            // if (intersects[0].object.voicestate == true) {
            intersects[0].object.material.opacity = .5
                // } else{
                // 	intersects[0].object.material.color.setHex(0xFF0000);
                // 	 intersects[0].object.material.opacity = .5
                // }


        }
    }

    //

    function animate() {

        requestAnimationFrame(animate);

        render();
        stats.update();

    }

    var radius = 600;
    var theta = 0;

    function render() {

        theta += 0.1;

        camera.lookAt(scene.position);

        renderer.render(scene, camera);

    }
    </script>
</body>

</html>
